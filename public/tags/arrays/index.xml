<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arrays on Andrew Attilio</title>
    <link>/tags/arrays/</link>
    <description>Recent content in arrays on Andrew Attilio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2023 Andrew Attilio</copyright>
    <lastBuildDate>Thu, 09 Nov 2023 14:10:55 -0700</lastBuildDate><atom:link href="/tags/arrays/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Two Sum</title>
      <link>/dsa/two-sum/</link>
      <pubDate>Thu, 09 Nov 2023 14:10:55 -0700</pubDate>
      
      <guid>/dsa/two-sum/</guid>
      <description>Two Sum Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Solution The naive approach is nested for loops, where we iterate through each element i and compare it to each element j.</description>
      <content>&lt;h1 id=&#34;two-sum&#34;&gt;Two Sum&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;
&lt;p&gt;You can return the answer in any order.&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;The naive approach is nested for loops, where we iterate through each element &lt;code&gt;i&lt;/code&gt; and compare it to each element &lt;code&gt;j&lt;/code&gt;. This has a time complexity of O(n^2) due to iterating through nums n*n times.&lt;/p&gt;
&lt;p&gt;An objectively better approach is to utilize a hash map. We can iterate through the list only once, checking if the current number has a complementary number in the hash_table that adds to the target. If they do, we return a list with the two indices. If not, we add &lt;code&gt;nums[i]&lt;/code&gt; to the hash table and continue iterating. This approach has a time complexity of O(n) because we iterate through the list only once.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Solution(object):
def twoSum(self, nums, target):
    hash_table = {}

    for i in range(len(nums)):
        if target - nums[i] in hash_table:
            return [hash_table[target-nums[i]], i]
        hash_table[nums[i]] = i

    return [] # no matches
&lt;/code&gt;&lt;/pre&gt;</content>
    </item>
    
  </channel>
</rss>
